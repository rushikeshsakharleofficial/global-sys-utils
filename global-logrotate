#!/usr/bin/bash
source /etc/bashrc
REQUIRED_CMDS=("find" "awk" "gzip" "cp" "mv" "date" "mkdir" "basename" "xargs")

check_commands() {
  local missing=()
  for cmd in "${REQUIRED_CMDS[@]}"; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
      missing+=("$cmd")
    fi
  done

  if [ ${#missing[@]} -ne 0 ]; then
    echo "Error: The following required command(s) are missing: ${missing[*]}"
    exit 1
  fi
}

check_commands

LOG_DIR="/var/log/apps"
DATE_SUFFIX=""
PATTERN="*.log"
CUSTOM_PATH_USED=false
RETENTION_DAYS=""
DRY_RUN=false
OLD_LOGS_DIR=""
PARALLEL=false
PARALLEL_JOBS=4

show_help() {
  echo "Usage: $0 [-H] [-D] [--pattern <glob>] [-p /path/to/logs] [-r days] [-n] [-o /path/to/old_logs] [--parallel N]"
  echo ""
  echo "Options:"
  echo "  -H                Use full timestamp format (YYYYMMDDTHH:MM:SS)"
  echo "  -D                Use date-only format (YYYYMMDD)"
  echo "  --pattern <glob>  File pattern to rotate (default: *.log)"
  echo "  -p <path>         Specify custom log directory (default: /var/log/apps)"
  echo "  -r <days>         Purge rotated logs older than <days>"
  echo "  -n                Dry-run mode (no changes made)"
  echo "  -o <path>         Specify old_logs directory (default: <logdir>/old_logs)"
  echo "  --parallel N      Rotate up to N log files in parallel (default: 4)"
  echo ""
  exit 1
}

# Show help if no arguments are provided or all arguments are empty/whitespace
if [ $# -eq 0 ] || [[ -z "${*// }" ]]; then
  show_help
fi

# Parse short and long options
ARGS=()
while [[ $# -gt 0 ]]; do
  case "$1" in
    -H) DATE_SUFFIX=$(date +%Y%m%dT%H:%M:%S); shift ;;
    -D) DATE_SUFFIX=$(date +%Y%m%d); shift ;;
    --pattern)
      PATTERN="$2"; shift 2 ;;
    -p) LOG_DIR="$2"; CUSTOM_PATH_USED=true; shift 2 ;;
    -r) RETENTION_DAYS="$2"; shift 2 ;;
    -n) DRY_RUN=true; shift ;;
    -o) OLD_LOGS_DIR="$2"; shift 2 ;;
    --parallel)
      PARALLEL=true
      if [[ -n $2 && $2 =~ ^[0-9]+$ ]]; then
        PARALLEL_JOBS=$2
        shift 2
      else
        shift 1
      fi
      ;;
    -h|--help) show_help ;;
    --) shift; break ;;
    -*) show_help ;;
    *) ARGS+=("$1"); shift ;;
  esac
done
set -- "${ARGS[@]}"

if $CUSTOM_PATH_USED && [ ! -d "$LOG_DIR" ]; then
  echo "Error: Custom log path '$LOG_DIR' does not exist."
  exit 1
fi

if [ -z "$DATE_SUFFIX" ]; then
  DATE_SUFFIX=$(date +%Y%m%d)
fi

# Remove trailing slash if present
LOG_DIR="${LOG_DIR%/}"
BACKUP_DIR="$OLD_LOGS_DIR/$(date +%Y%m%d)"

LOG_FILES=$(find "$LOG_DIR" -type f -name "$PATTERN" -printf "%s %p\n" 2>/dev/null | sort -n | awk '{print $2}')

if [ -z "$LOG_FILES" ]; then
  echo "No files matching pattern '$PATTERN' found in $LOG_DIR"
  exit 0
fi

rotate_log_file() {
  LOG_FILE="$1"
  if [ -f "$LOG_FILE" ] && [ -s "$LOG_FILE" ]; then
    # Get directory and basename of log file
    local log_dir=$(dirname "$LOG_FILE")
    local log_name=$(basename "$LOG_FILE")
    local rotated_basename="${log_name}.${DATE_SUFFIX}"
    local backup_root
    local backup_dir
    local archived_file
    
    # Set backup locations
    if [ -n "$OLD_LOGS_DIR" ]; then
      # If -o specified, use central backup directory
      backup_root="$OLD_LOGS_DIR"
    else
      # Otherwise use local old_logs directory
      backup_root="${log_dir}/old_logs"
    fi
    
    # Create backup path with date
    backup_dir="$backup_root/$(date +%Y%m%d)"
    archived_file="$backup_dir/${rotated_basename}.gz"

    if [ -f "$archived_file" ]; then
      echo "$(date): Already rotated, skipping: $LOG_FILE"
      return
    fi

    if $DRY_RUN; then
      echo "[DRY-RUN] Would Rotate: ${LOG_FILE} -> $archived_file"
    else
      mkdir -p "$backup_dir"
      cp "$LOG_FILE" "$backup_dir/${rotated_basename}"
      > "$LOG_FILE"
      gzip "$backup_dir/${rotated_basename}"
      echo "$(date): Rotated: $LOG_FILE -> $archived_file"
    fi
  else
    echo "$(date): Skipping empty or missing file: $LOG_FILE"
  fi

  if [ -n "$RETENTION_DAYS" ]; then
    # PURGE_DIR is already set above based on OLD_LOGS_DIR
    if $DRY_RUN; then
      echo "[DRY-RUN] Would delete files older than $RETENTION_DAYS days in $PURGE_DIR"
    else
      find "$PURGE_DIR" -type f -name "*.gz" -mtime +$RETENTION_DAYS -exec rm -f {} \;
      echo "$(date): Purged logs older than $RETENTION_DAYS days in $PURGE_DIR"
    fi
  fi
}

export -f rotate_log_file
export DATE_SUFFIX OLD_LOGS_DIR DRY_RUN RETENTION_DAYS

if $PARALLEL; then
  echo "$LOG_FILES" | xargs -r -n 1 -P $PARALLEL_JOBS bash -c 'rotate_log_file "$0"'
else
  for LOG_FILE in $LOG_FILES; do
    rotate_log_file "$LOG_FILE"
  done
fi
