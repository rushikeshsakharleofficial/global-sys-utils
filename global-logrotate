#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'

# Defaults
LOG_DIR=""
FILE_PATTERN="*.log"
DRY_RUN=false
PARALLEL=4
DEST_DIR=""           # optional

# Timestamp flags
USE_FULL_TIMESTAMP=false
USE_DATE_ONLY=false

FULL_TIMESTAMP_FORMAT="%Y%m%dT%H:%M:%S"
DATE_ONLY_FORMAT="%Y%m%d"

usage() {
  cat <<EOF
Usage: $0 -H|-D -p <log_dir> [-o <dest_dir>] [options]

Required (choose one):
  -H                Full timestamp (YYYYMMDDTHH:MM:SS)
  -D                Date-only format (YYYYMMDD)

Required:
  -p <dir>          Directory containing log files

Optional:
  -o <dir>          Global destination root (default: file's own parent/old_logs)
  -f <pattern>      File pattern (default: *.log)
  -n                Dry-run (just print, no changes)
  --parallel <N>    Parallel jobs (default: 4)
  -h, --help        Show this help
EOF
  exit 1
}

# Parse args
while (( $# )); do
  case $1 in
    -H) USE_FULL_TIMESTAMP=true; shift ;;
    -D) USE_DATE_ONLY=true;    shift ;;
    -p) LOG_DIR="$2";          shift 2 ;;
    -o) DEST_DIR="$2";         shift 2 ;;
    -f) FILE_PATTERN="$2";     shift 2 ;;
    -n) DRY_RUN=true;          shift ;;
    --parallel) PARALLEL="$2"; shift 2 ;;
    -h|--help) usage ;;
    *) echo "Unknown option: $1"; usage ;;
  esac
done

# Validate flags
if $USE_FULL_TIMESTAMP && $USE_DATE_ONLY; then
  echo "Error: Cannot use both -H and -D" >&2; usage
fi
if ! $USE_FULL_TIMESTAMP && ! $USE_DATE_ONLY; then
  echo "Error: Must specify either -H or -D" >&2; usage
fi
if [[ -z "$LOG_DIR" ]]; then
  echo "Error: -p <log_dir> is required" >&2; usage
fi

# Normalize and check LOG_DIR
LOG_DIR="${LOG_DIR%/}"
if [[ ! -d "$LOG_DIR" ]]; then
  echo "Error: Log directory not found: $LOG_DIR" >&2; exit 1
fi

# Determine timestamp
if $USE_FULL_TIMESTAMP; then
  TS_FMT="$FULL_TIMESTAMP_FORMAT"
else
  TS_FMT="$DATE_ONLY_FORMAT"
fi
TIMESTAMP="$(date +"$TS_FMT")"

# Collect files
mapfile -t LOG_FILES < <(
  find "$LOG_DIR" -maxdepth 1 -type f -name "$FILE_PATTERN" -size +0c 2>/dev/null
)

if ((${#LOG_FILES[@]} == 0)); then
  echo "No log files matching '$FILE_PATTERN' in $LOG_DIR"
  exit 0
fi

# Rotate function
rotate_file() {
  local file="$1"
  local parent base out_root final_dest dest

  parent=$(dirname "$file")
  base=$(basename "$file")

  # Decide root of destination
  if [[ -n "$DEST_DIR" ]]; then
    out_root="$DEST_DIR"
  else
    out_root="$parent/old_logs"
  fi

  final_dest="$out_root/$TIMESTAMP"
  if ! $DRY_RUN; then
    mkdir -p "$final_dest"
  fi

  dest="$final_dest/${base}.${TIMESTAMP}.gz"

  if $DRY_RUN; then
    echo "[DRY] $file → $dest"
  else
    gzip -c "$file" > "$dest" && : > "$file"
    echo "Rotated: $file → $dest"
  fi
}

export -f rotate_file
export TIMESTAMP DEST_DIR DRY_RUN

# Dispatch
if (( PARALLEL > 1 )); then
  printf '%s\n' "${LOG_FILES[@]}" \
    | xargs -r -n1 -P "$PARALLEL" bash -c 'rotate_file "$0"' 
else
  for f in "${LOG_FILES[@]}"; do
    rotate_file "$f"
  done
fi
