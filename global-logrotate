#!/usr/bin/env bash

source /etc/bashrc
set -euo pipefail

# Required commands
REQUIRED_CMDS=(find awk gzip date mkdir basename xargs cp)

check_commands() {
  local missing=()
  for cmd in "${REQUIRED_CMDS[@]}"; do
    if ! command -v "$cmd" &>/dev/null; then
      missing+=("$cmd")
    fi
  done
  if [[ ${#missing[@]} -ne 0 ]]; then
    echo "Error: Missing commands: ${missing[*]}" >&2
    exit 1
  fi
}
check_commands

# Initialize variables
LOG_DIR=""
PATTERN="*.log"
DRY_RUN=false
PARALLEL=false
PARALLEL_JOBS=4
TIMESTAMP_FORMAT="%Y%m%dT%H:%M:%S"
DATE_ONLY_FORMAT="%Y%m%d"
USE_DATE_ONLY=false

usage() {
  cat <<EOF
Usage: $0 -p <log_directory> [--pattern <glob>] [options]
Required:
  -p <dir>          Base log directory
Optional:
  --pattern <glob>  File pattern to rotate (default: *.log)
Options:
  -H                Use full timestamp (YYYYMMDDTHH:MM:SS)
  -D                Use date-only stamp (YYYYMMDD)
  -n                Dry-run mode
  --parallel [N]    Rotate in parallel (N jobs, default: 4)
  -h                Show this help message
EOF
  exit 1
}

# Show help if no arguments
if [[ $# -eq 0 ]]; then
  usage
fi

# Parse options
while [[ $# -gt 0 ]]; do
  case "$1" in
    -p) LOG_DIR="$2"; shift 2;;
    --pattern) PATTERN="$2"; shift 2;;
    -H) USE_DATE_ONLY=false; shift;;
    -D) USE_DATE_ONLY=true; shift;;
    -n) DRY_RUN=true; shift;;
    --parallel)
      PARALLEL=true
      if [[ -n ${2-} && $2 =~ ^[0-9]+$ ]]; then
        PARALLEL_JOBS="$2"; shift 2
      else
        shift
      fi;;
    -h|--help) usage;;
    *) echo "Error: Unknown option: $1" >&2; usage;;
  esac
done

# Validate required argument LOG_DIR
if [[ -z "$LOG_DIR" ]]; then
  echo "Error: -p <log_directory> is required." >&2
  usage
fi

# Function to get timestamp
get_timestamp() {
  if [[ "$USE_DATE_ONLY" == true ]]; then
    date +"$DATE_ONLY_FORMAT"
  else
    date +"$TIMESTAMP_FORMAT"
  fi
}

# Validate log dir
if [[ ! -d "$LOG_DIR" ]]; then
  echo "Error: Log directory not found: $LOG_DIR" >&2
  exit 1
fi

# Gather non-empty log files
mapfile -t LOG_FILES < <(find "$LOG_DIR" -type f -name "$PATTERN" -size +0c)
if [[ ${#LOG_FILES[@]} -eq 0 ]]; then
  echo "No non-empty log files matching '$PATTERN' in $LOG_DIR"
  exit 0
fi

# Rotation function
rotate_file() {
  local file="$1"
  local ts parent base dest_dir tmp_file archive

  parent=$(dirname "$file")
  base=$(basename "$file")

  # Skip compressed files
  if [[ "$base" == *.gz ]]; then
    echo "Skipping already compressed file: $file"
    return
  fi

  ts=$(get_timestamp)
  dest_dir="$parent/old_logs/$(date +"$DATE_ONLY_FORMAT")"
  tmp_file="$dest_dir/${base}.${ts}"
  archive="$tmp_file.gz"

  # Create dest directory
  if ! $DRY_RUN; then
    mkdir -p "$dest_dir"
  fi

  # Skip if archive exists
  if [[ -f "$archive" ]]; then
    echo "Already rotated: $file"
    return
  fi

  if $DRY_RUN; then
    echo "[DRY] Rotate: $file -> $archive"
  else
    cp "$file" "$tmp_file"
    : > "$file"
    gzip "$tmp_file"
    echo "Rotated: $file -> $archive"
  fi
}

# Export for parallel
export -f rotate_file get_timestamp
export DRY_RUN TIMESTAMP_FORMAT DATE_ONLY_FORMAT USE_DATE_ONLY

# Execute rotation
if [[ "$PARALLEL" == true ]]; then
  printf "%s\n" "${LOG_FILES[@]}" | xargs -P "$PARALLEL_JOBS" -n1 bash -c 'rotate_file "$0"'
else
  for file in "${LOG_FILES[@]}"; do
    rotate_file "$file"
  done
fi

